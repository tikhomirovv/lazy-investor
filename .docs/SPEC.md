## SPEC (черновик спецификации)

Этот документ описывает целевую систему: **безопасный торговый советник** (advisor), который собирает данные, считает метрики и сигналы детерминированно, применяет политики и риск‑контроль, затем формирует **намерения (intents)** и отправляет их в Telegram для **ручного подтверждения**.  
Опционально позже система сможет **исполнять** сделки автоматически, но только после подтверждения и повторной валидации.

Фокус спецификации — **процессные гарантии** (безопасность, лимиты, воспроизводимость, аудит), а не “гарантированная прибыль”.

---

## 1) Цели

- **Safety-first**: автоматизировать сбор данных и анализ, но минимизировать риск ошибочных сделок.
- **Детерминированное ядро**: индикаторы, сигналы стратегий, риск‑оценки — только кодом, воспроизводимо.
- **LLM как советник**: LLM объясняет и предлагает варианты, но **не обходит** политики/риск‑шлюз.
- **Telegram интерфейс**: бот присылает отчёт и intent, даёт кнопки **Approve / Reject**.
- **Песочница / бэктест**: возможность прогонять стратегии на исторических свечах, торгуя “виртуальным портфелем”.
- **Расширяемость**: легко добавлять стратегии, индикаторы, источники данных, политики.

## 2) Не-цели (для MVP)

- HFT/ультранизкие задержки.
- Полностью автономная торговля без строгих лимитов и аудита.
- “Одна подсказка LLM на всё” без формальных контрактов и проверок.

---

## 3) Высокоуровневая архитектура (потоки)

### 3.1 Поток “Advisor” (основной, безопасный)

1. **Scheduler** запускает цикл по таймфрейму (например, D1/W1).
2. **MarketData** загружает историю и актуальные данные (свечи/объёмы/цены).
3. **FeatureEngine** считает фичи и индикаторы (детерминированно).
4. **SignalEngine** считает сигналы стратегий (детерминированно).
5. **Policy & Risk Engine** применяет политики, ограничения и риск‑лимиты.
6. **LLM Advisor** получает структурированный snapshot и возвращает intent.
7. **Intent Store** сохраняет intent со статусом `pending` и TTL.
8. **Telegram Bot** отправляет intent и отчёт. Пользователь нажимает Approve/Reject.
9. При Approve:
   - фиксируем подтверждение (audit),
   - (опционально) формируем “исполняемый” ордер через детерминированный маппинг,
   - (опционально) **Execution Engine** выставляет ордер.

### 3.2 Поток “Sandbox/Backtest”

Та же архитектура, но MarketData читает **историю**, а TradingAdapter — **симулятор**:
- обновляет виртуальный портфель,
- учитывает комиссии/проскальзывание (упрощённая модель на старте),
- пишет журнал сделок и метрик.

---

## 4) Модули (MVP)

- **Scheduler**
  - запуск по cron/интервалу в рамках выбранного таймфрейма.
  - защита от параллельных запусков одного и того же окна времени.

- **MarketData**
  - исторические свечи (D1/W1/MN1) и “последняя свеча”.
  - метаданные инструмента: валюта, лотность, шаг цены, торговые часы (если доступно).

- **FeatureEngine**
  - доходности, волатильность (ATR/realized), тренд‑метрики, корреляции.
  - уровни/экстремумы (swing high/low), диапазоны.

- **SignalEngine**
  - библиотека стратегий с единым интерфейсом:
    - вход: snapshot фич,
    - выход: сигнал (buy/sell/hold), “цена/уровни”, уверенность, причины.

- **Policy & Risk Engine**
  - жёсткие лимиты: max позиция, max риск на сделку, max убыток/день, max просадка, запреты.
  - условия “no-trade”: плохие данные, рынок закрыт, аномальный спред, высокая волатильность и т.п.
  - позиционирование: расчёт допустимого размера позиции.

- **Knowledge Base (LLM Context)**
  - локальная база знаний в виде **Markdown-файлов**, которые добавляются в контекст LLM.
  - цель: передавать LLM актуальные “правила/паттерны/наблюдения/гайды” без fine-tuning.
  - хранение: папка `knowledge/` в репозитории.
  - выбор того, что включать в контекст: простой **manifest** (список файлов).
  - безопасность: знания не отменяют политики/риск‑контроль; это только “справка” для LLM.

- **LLM Advisor**
  - получает только **структурированный snapshot** (JSON) + политики.
  - возвращает только **структурированный intent** (JSON).
  - не имеет прямого доступа к “place order”.

### 4.x LLM провайдеры и абстракции (архитектурное правило)

Требование: интеграция с LLM должна быть **заменяемой** и изолированной.
Мы не привязываем ядро и app-слой к конкретному API/SDK.

- В `internal/ports` определяем **узкие use-case интерфейсы**, а не “универсальный чат”:
  - `LLMAdvisor` — только для intents (snapshot → intent).
  - `LLMFundamentalAnalyst` — только для фундаментального анализа (doc → structured analysis).
  - (при необходимости) другие интерфейсы под конкретные задачи.
- В `internal/adapters/llm/*` реализуем провайдеров (OpenAI/Anthropic/local/stub/…).
- Выбор провайдера делается **через конфигурацию по use-case**, например:
  - `llm.advisor.provider = openai | anthropic | local | stub`
  - `llm.fundamental.provider = anthropic | local | stub`
  - параметры модели (`model`, `temperature`, `max_tokens`, `timeouts`) задаются отдельно.
- Внутри адаптера допускается “router/factory”, который выбирает нужного провайдера, но этот выбор **не должен** быть размазан по коду приложения.
- Валидация: ответы LLM должны валидироваться по JSON-схемам на границе адаптера (не в ядре), с понятными ошибками/логами.
- Аудит: фиксируем минимум (provider, model, prompt/template version, request/response hash, timestamps) для воспроизводимости.

- **Telegram Bot**
  - отправляет intent и краткий отчёт.
  - кнопки Approve/Reject.
  - защита: подтверждение только в пределах TTL и только один раз (idempotency).

- **Intent Store**
  - хранение intents: `id`, `created_at`, `expires_at`, `status`, `payload`, `decision`.
  - аудит: кто подтвердил/отклонил, когда, с какого chat/user id.

---

## 5) Фундаментальный контур (дополнительный модуль)

Цель: добавлять **вспомогательные** фундаментальные сигналы для крупных ТФ (D1/W1/MN1).
Это отдельный контур, который можно **включать/выключать** и который может использовать **другую LLM/другого провайдера**, не связанную с LLM “для принятия решений”.

### 5.1 Data sources

- список источников задаётся явно (whitelist):
  - RSS/Atom,
  - конкретные страницы,
  - официальные релизы (если доступны),
  - финансовые календари/отчётность (опционально).

### 5.2 Pipeline

Этот пайплайн запускается **отдельной командой/скриптом** (offline ingestion), не в основном цикле Advisor.

1. **Fetcher** (без LLM) скачивает HTML/текст/ленты по указанным URL/ленточным источникам.
2. **Extractor** извлекает “чистый текст” + метаданные (title, date, source, url).
3. **LLM Fundamental Analyst** (может быть другой провайдер/модель) получает:
   - извлечённый текст,
   - тикер/инструмент,
   - правила (что считать важным),
   и возвращает:
   - краткое резюме,
   - потенциальные риски/события,
   - оценку влияния (qualitative),
   - ссылки на источники,
   - уровень уверенности.
4. **Fundamental Store** сохраняет результат анализа в БД/хранилище:
   - исходные метаданные источника,
   - извлечённый текст (или ссылку/хеш),
   - ответ LLM (структурировано),
   - привязку к инструменту (если удалось),
   - время/период актуальности.

### 5.3 Включение в Advisor (на уровне архитектуры)

В основном пайплайне Advisor фундаментальные результаты не “выкачиваются с сайтов”.
Advisor лишь читает подготовленные записи из `Fundamental Store` (например, “за последние N дней” и/или “по конкретному инструменту”) и добавляет их в snapshot как дополнительный контекст.
Точная логика выборки (по времени/по инструменту/по событиям) будет определена позже; сейчас важно зафиксировать саму возможность и границы ответственности.

### 5.4 Важно

- фундаментальные данные **никогда** не должны быть единственным триггером сделки.
- любой вывод LLM должен быть трассируем: “какой источник → какой вывод”.

---

## 6) Контракты данных (обязательные схемы)

### 6.1 Snapshot (вход LLM)

Snapshot должен быть компактным и структурированным. Минимально:
- таймфрейм, время, список инструментов,
- последние N свечей (или агрегаты),
- ключевые фичи/индикаторы,
- сигналы стратегий,
- состояние портфеля и риск‑лимиты,
- ограничения исполнения (лотность, шаг цены, торговые часы),
- результаты фундаментального контура (если включён).
- выбранные документы из **Knowledge Base** (если включено), например:
  - список включённых файлов,
  - их содержимое (как текстовые блоки) или хеши + ссылки (если решим хранить отдельно).

### 6.2 Intent (выход LLM)

Intent — это **предложение**. Минимально:
- `intent_id`, `timeframe`, `instrument`,
- `action`: BUY/SELL/HOLD,
- предложенные параметры (quantity/price/stop/take), но как **рекомендация**,
- причины (коротко и структурированно),
- preconditions (условия, при которых intent валиден),
- `confidence` (0..1),
- `expires_at` / TTL.

### 6.3 Маппинг в API брокера

Даже если intent содержит поля “как в API брокера”, итоговый ордер должен быть:
- **пересобран** детерминированным кодом,
- **валидирован** (лоты, шаг цены, торговые условия),
- подписан idempotency key.

---

## 7) Безопасность и контроль рисков (обязательно)

- лимиты по позиции и риску (per-trade / per-day / portfolio),
- запрет сделок при аномалиях данных,
- запрет повторного исполнения одного intent,
- подтверждение только до истечения TTL,
- журналирование всех решений:
  - входные данные (hash + ссылки на данные),
  - рассчитанные фичи,
  - результаты стратегий,
  - решение LLM,
  - решение пользователя,
  - итог (исполнено/отклонено/истекло).

---

## 8) Sandbox / Paper / Backtest

### 8.1 TradingAdapter интерфейс

Система должна уметь работать с разными адаптерами:
- `RealBrokerAdapter` (реальные ордера),
- `SandboxBrokerAdapter` (если у брокера есть sandbox API),
- `BacktestAdapter` (симуляция на истории).

### 8.2 BacktestAdapter (требования)

- виртуальный портфель (cash + позиции),
- учёт:
  - комиссий,
  - проскальзывания (простая модель на старте),
  - ограничений лотности,
  - торговых часов (если важно),
- метрики:
  - equity curve,
  - max drawdown,
  - win rate, profit factor,
  - exposure, turnover,
  - сравнение с бенчмарком (опционально).

---

## 9) Этапы внедрения

- **Stage 0**: Scheduler + MarketData + простые расчёты + Telegram отчёты. Без индикаторов, без intents, без LLM.
- **Stage 1**: индикаторы (хотя бы 2–3) и расширение отчётов. Всё ещё без intents и без LLM.
- **Stage 2 (MVP)**: intents + Telegram Approve/Reject + Knowledge Base контекст для LLM. Без исполнения.
- **Stage 3**: исполнение после Approve (малые лимиты).
- **Stage 4 (опционально)**: фундаментальный ingestion (Fetcher/Extractor/LLM Fundamental Analyst) + сохранение в хранилище + добавление результатов в snapshot.

---

## 10) Зависимости и возможность “быстро убрать библиотеку”

Требование: можно использовать `github.com/cinar/indicator/v2` (для личного использования), но архитектура должна позволять:
- заменить провайдер индикаторов на другой (например, `github.com/markcheno/go-talib`),
- временно отключить стратегии, предоставляемые сторонней библиотекой,
- удалить зависимость, не “сломав” остальной проект.

### 10.1 Правило архитектуры

- В проекте есть **внутренние интерфейсы** (контракты), через которые ядро работает с индикаторами и стратегиями.
- Любая внешняя библиотека подключается только через **адаптер**, который реализует эти интерфейсы.
- Вне адаптера по коду не должно быть импортов `cinar/indicator` / `go-talib`.

### 10.2 Интерфейсы (концептуально)

Ниже — концептуальные интерфейсы (названия условные). Их смысл:
- ядро работает с абстракциями,
- реализация может быть на `indicator`, на `go-talib`, либо на “заглушках”.

- **IndicatorProvider**
  - вход: OHLCV + параметры индикатора,
  - выход: рассчитанный ряд (series) + метаданные (например, lookback).

- **StrategyProvider**
  - вход: OHLCV/feature snapshot,
  - выход: детерминированный сигнал (например, BUY/SELL/HOLD) + причины (в структурированном виде).

Важно: стратегии из `indicator` возвращают только `Hold/Buy/Sell`. Размер позиции, стопы, тип ордера — это ответственность нашего **Policy & Risk Engine** и “интент‑слоя”.

### 10.3 Реализации (адаптеры)

- **IndicatorAdapterIndicator**
  - использует `cinar/indicator/v2` для расчёта индикаторов и (опционально) готовых стратегий.

- **IndicatorAdapterTalib**
  - использует `markcheno/go-talib` для расчёта индикаторов.
  - стратегии библиотека не даёт — значит `StrategyProvider` реализуется либо нашими стратегиями, либо простыми заглушками.

- **Stub / Noop adapters**
  - для тестов и “безопасного режима”: возвращают фиксированные значения или “HOLD”.

### 10.4 Конфигурация выбора реализации

Выбор реализации провайдера делается через конфигурацию приложения:
- `indicator_provider = indicator | talib | stub`
- `strategy_provider = indicator | builtin | stub`

При этом смена провайдера не должна влиять на остальные модули (LLM, Telegram, Policy/Risk, Storage).

---

## 11) Тестирование и изоляция тестов сторонней библиотеки

Требование: иметь возможность использовать “тестовые данные/подход” из `indicator`, но при необходимости быстро отключать эти тесты.

### 11.1 Базовый набор тестов (всегда включён)

- тесты контрактов наших интерфейсов (IndicatorProvider/StrategyProvider),
- тесты стабильности (одинаковый вход → одинаковый выход),
- тесты lookback/границ (короткие ряды, пропуски, нули, extreme значения),
- тесты политики/риск‑гейта (intent не проходит лимиты → отклоняется).

### 11.2 “Indicator-specific” тесты (опционально)

Подход: хранить тесты совместимости/валидации, завязанные на `cinar/indicator`, отдельно и делать их **опциональными**.

Технические варианты (выбирается один, самый простой):
- **Go build tags**:
  - файлы вида `*_indicator_test.go` с `//go:build indicator`,
  - запускаются только так: `go test -tags=indicator ./...`
  - по умолчанию (без tags) эти тесты не исполняются.

- **Отдельный пакет тестов**:
  - например, `internal/compat/indicator/...`,
  - его можно исключать из стандартного пайплайна тестирования.

Цель: чтобы при удалении `cinar/indicator` из зависимостей:
- основной проект компилировался,
- основной набор тестов проходил,
- “indicator-specific” тесты просто не запускались (или были удалены без каскадных правок).

---

## 12) Предлагаемая структура проекта (черновик)

Цель: зафиксировать **скелет** проекта и границы модулей так, чтобы:
- детерминированное ядро (данные/фичи/сигналы/политики) было изолировано,
- внешние интеграции (Tinkoff, Telegram, LLM, источники фундаментала) подключались через адаптеры,
- можно было “переписать всё” без потери полезных инфраструктурных кусочков.

### 12.1 Директории (рекомендация)

- `cmd/`
  - `advisor/` — основной процесс: scheduler → data → features → signals → policy/risk → intent → telegram.
  - `backtest/` — CLI/процесс прогонов на истории (BacktestAdapter).
  - `telegram-bot/` — отдельный процесс, если нужно разделить ответственность (опционально; в MVP может жить внутри `advisor`).

- `internal/` (всё “приватное”, не как библиотека)
  - `app/` — композиция use-cases/оркестрация (pipeline).
  - `domain/` — сущности и правила предметной области:
    - `candle`, `instrument`, `portfolio`, `intent`, `policy`, `risk`, `signal`, `timeframe`.
  - `ports/` — интерфейсы (контракты), через которые домен/приложение общается с внешним миром:
    - `MarketDataProvider`, `IndicatorProvider`, `StrategyProvider`, `FundamentalProvider`,
    - `LLMAdvisor`, `TelegramNotifier`, `IntentStore`, `BrokerAdapter`.
  - `adapters/` — реализации портов:
    - `marketdata/tinkoff/` — получение свечей/метаданных через Tinkoff SDK,
    - `indicators/indicator/` — адаптер к `cinar/indicator/v2`,
    - `indicators/talib/` — адаптер к `markcheno/go-talib` (на будущее),
    - `telegram/` — Telegram Bot API,
    - `llm/` — провайдер LLM (HTTP API) + строгие JSON-схемы,
    - `fundamental/` — fetch/extract + LLM summary,
    - `store/` — хранилища intents (in-memory/sql/redis/file).
  - `infra/` — инфраструктурные утилиты:
    - конфиг, логирование, graceful shutdown, retry/backoff, time, idempotency.

- `pkg/` (опционально)
  - только если ты хочешь переиспользуемые пакеты “как библиотеку”. Для приложения можно вообще обойтись без `pkg/`.

- `knowledge/` (новое)
  - Markdown-файлы с “знаниями” для LLM (торговые принципы, рынок, правила интерпретации сигналов).
  - простой manifest (список файлов), которые нужно включать в контекст LLM.

### 12.2 Границы ответственности (важно)

- `internal/domain` не импортирует внешние SDK и библиотеки индикаторов напрямую.
- `internal/app` знает только интерфейсы из `internal/ports`.
- `internal/adapters/*` — единственное место, где допускаются импорты:
  - `cinar/indicator`,
  - `tinkoff SDK`,
  - Telegram/LLM/HTTP клиенты.

### 12.3 Что из текущего кода имеет смысл сохранить и “перенести”

- **Tinkoff MarketData**: логика получения свечей и поиск инструмента (как `MarketDataProvider` адаптер).
- **Chart генерация**: генерация PNG-графиков может быть полезна для отчётов/Telegram (как отдельный `ReportRenderer`/`ChartRenderer` модуль).
- **Graceful shutdown**: шаблон запуска/остановки сервиса (infra).

Важно: перенос делаем не “как есть”, а через адаптеры под порты из `internal/ports`.

