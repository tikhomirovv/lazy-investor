## Features / FeatureEngine (Stage 1+)

Этот документ фиксирует правила и шаблон работы с **фичами (features)**.
Цель — развивать систему последовательно: сначала понимаем индикатор и формат фич, затем реализуем.

Файл дополняет `.docs/ARCHITECTURE.md` и используется как “чеклист” при внедрении Stage 1.

---

### 1) Термины (простыми словами)

- **Candles (свечи)**: сырые рыночные данные (OHLCV + время).
- **Indicator (индикатор)**: детерминированная функция от серии свечей/цен. Выдаёт число или ряд чисел.
- **Feature (фича)**: готовый признак для принятия решения. Обычно это индикатор + контекст:
  - текущее значение,
  - предыдущее значение,
  - изменение,
  - состояние (“зона”, “тренд”, “готов/не готов”),
  - события (“пересечение”, “выход из зоны”),
  - параметры (period и т.п.).

Важно: решение принимает не “индикатор”, а **стратегия/логика** на основе фич.
Фичи нужны, чтобы эту логику сделать компактной, воспроизводимой и объяснимой.

---

### 2) Базовые принципы FeatureEngine

- **Детерминизм**: одинаковые входные свечи → одинаковые фичи.
- **Закрытые свечи**: фичи для решений считаем только по полностью закрытым свечам выбранного таймфрейма.
- **Readiness (warmup)**: если истории недостаточно, фича должна явно сообщать `ready=false` (а не “молчать”).
- **Минимум шума**: мы передаём дальше не “простыню рядов”, а компактные фичи + события.
- **Единый формат**: разные индикаторы могут иметь разные параметры, но результат должен укладываться в общий контракт.

---

### 3) Правило разработки (пошаговый процесс)

Мы **не лепим всё сразу**. Работа идёт по одному индикатору/набору фич за раз.

1) **Осмысление индикатора**
   - что он измеряет,
   - какие у него параметры,
   - какой warmup/lookback,
   - какие “события” и “состояния” из него полезны.

2) **Спецификация фич**
   - какие поля входят в результат,
   - как вычисляются `state/events`,
   - какие входы нужны (сколько свечей N),
   - какие edge cases (малые ряды, пропуски, нули),
   - какие тесты доказывают корректность и детерминизм.

3) **План реализации**
   - где живёт код (FeatureEngine),
   - какие индикаторы/адаптеры вызываются и сколько раз,
   - как обеспечиваем `ready` и отсутствие двусмысленности,
   - как включаем в отчёт и (позже) в snapshot для LLM.

4) **Реализация + тесты**
   - реализуем минимально необходимое,
   - добавляем тесты на детерминизм/границы,
   - обновляем отчёт (Stage 1) и проверяем руками.

---

### 4) Шаблон описания индикатора и фич (копировать для каждого индикатора)

#### 4.1 Indicator: <NAME>

- **Purpose**: что измеряет и зачем нам это.
- **Inputs**: какие данные нужны (обычно `close[]`, иногда OHLCV).
- **Parameters**: period, smoothing, thresholds.
- **Warmup / Lookback**: минимальное число свечей для `ready=true`.
- **Output (raw)**: что выдаёт индикатор (значение/ряд).

#### 4.2 Features from <NAME>

Обязательный минимум (если применимо):
- `value`: текущее значение.
- `prev`: предыдущее значение (для сравнения).
- `delta`: `value - prev`.
- `ready`: достаточно ли истории для корректного значения.

State (детерминированно, без LLM):
- `state`: короткая метка, которая помогает объяснять ситуацию (пример: `oversold`, `neutral`, `overbought`).

Events (детерминированно):
- `events[]`: список событий, важных для решений (пример: `crossed_up_30`).

Edge cases:
- что делаем при малой истории, нулях, пропусках, “плоском” рынке.

Tests:
- одинаковый вход → одинаковый выход,
- warmup границы (N-1 свеча vs N свечей),
- корректность событий на синтетических рядах.

LLM snapshot mapping:
- какие поля мы отправляем в snapshot,
- какие поля не отправляем (чтобы не раздувать контекст).

---

### 5) Минимальный контракт FeatureSet (Stage 1)

В Stage 1 нам достаточно компактного набора фич для отчёта и будущего snapshot:

- `value`, `prev`, `delta`, `ready`
- `state` (если индикатор имеет естественные состояния)
- `events[]` (если можно выделить события, полезные для решений)

Для комбинированных фич (на базе 2+ индикаторов) также используем `value/prev/delta/events/ready`, но без лишней математики.

---

### 6) Стартовый набор (для текущих SMA20 / EMA20 / RSI14)

Этот набор согласован с `.docs/ARCHITECTURE.md` (Stage 1) и служит отправной точкой.

- **SMA20**
  - `sma20.value`, `sma20.prev`, `sma20.delta`, `sma20.ready`
  - `events`: `price_above_sma20`, `price_crossed_up_sma20`, `price_crossed_down_sma20`

- **EMA20**
  - `ema20.value`, `ema20.prev`, `ema20.delta`, `ema20.ready`
  - `events`: `price_above_ema20`, `price_crossed_up_ema20`, `price_crossed_down_ema20`

- **RSI14**
  - `rsi14.value`, `rsi14.prev`, `rsi14.delta`, `rsi14.ready`
  - `state`: `oversold|neutral|overbought` (например пороги 30/70)
  - `events`: `rsi14_crossed_up_30`, `rsi14_crossed_down_70`

Комбинированные (дешёвые и полезные):
- `ema20_above_sma20`
- `ema20_crossed_above_sma20`, `ema20_crossed_below_sma20`

